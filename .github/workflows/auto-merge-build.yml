name: Auto-Merge PRs and Build Enhanced Dokploy

on:
  schedule:
    # Run daily at 00:00 UTC
    - cron: '0 0 * * *'
  workflow_dispatch:
    inputs:
      pr_numbers:
        description: 'Comma-separated PR numbers to merge (overrides env variable)'
        required: false
        type: string
      dokploy_branch:
        description: 'Dokploy branch to use as base (default: canary)'
        required: false
        default: 'canary'
        type: string
      skip_build:
        description: 'Skip Docker build (useful for testing merge only)'
        required: false
        default: false
        type: boolean

env:
  # Configure PR numbers to merge (comma-separated)
  # Example: "1234,5678,9012"
  PR_NUMBERS_TO_MERGE: ${{ vars.PR_NUMBERS_TO_MERGE || '' }}

  # Docker registry configuration
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository_owner }}/dokploy-enhanced

  # Upstream Dokploy repository
  UPSTREAM_REPO: Dokploy/dokploy
  UPSTREAM_BRANCH: canary

jobs:
  # ==========================================================================
  # Clone and Merge PRs
  # ==========================================================================
  prepare-source:
    runs-on: ubuntu-latest
    outputs:
      merged_prs: ${{ steps.merge-prs.outputs.merged_prs }}
      failed_prs: ${{ steps.merge-prs.outputs.failed_prs }}
      build_version: ${{ steps.meta.outputs.build_version }}
      upstream_sha: ${{ steps.clone.outputs.upstream_sha }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Git
        run: |
          git config --global user.name "GitHub Actions Bot"
          git config --global user.email "actions@github.com"

      - name: Clone upstream Dokploy repository
        id: clone
        run: |
          BRANCH="${{ inputs.dokploy_branch || env.UPSTREAM_BRANCH }}"
          echo "Cloning upstream Dokploy from branch: $BRANCH"
          git clone --depth=1 --branch "$BRANCH" "https://github.com/${{ env.UPSTREAM_REPO }}.git" dokploy-source
          cd dokploy-source
          git fetch --unshallow || true
          UPSTREAM_SHA=$(git rev-parse HEAD)
          echo "upstream_sha=$UPSTREAM_SHA" >> $GITHUB_OUTPUT
          echo "Upstream SHA: $UPSTREAM_SHA"

      - name: Determine PRs to merge
        id: determine-prs
        run: |
          # Use workflow input if provided, otherwise use env variable
          if [ -n "${{ inputs.pr_numbers }}" ]; then
            PR_LIST="${{ inputs.pr_numbers }}"
          else
            PR_LIST="${{ env.PR_NUMBERS_TO_MERGE }}"
          fi

          echo "PR_LIST=$PR_LIST" >> $GITHUB_ENV
          echo "PRs to merge: $PR_LIST"

          if [ -z "$PR_LIST" ]; then
            echo "No PRs configured to merge"
            echo "has_prs=false" >> $GITHUB_OUTPUT
          else
            echo "has_prs=true" >> $GITHUB_OUTPUT
          fi

      - name: Fetch and merge PRs
        id: merge-prs
        if: steps.determine-prs.outputs.has_prs == 'true'
        run: |
          cd dokploy-source

          MERGED_PRS=""
          FAILED_PRS=""

          # Parse comma-separated PR numbers
          IFS=',' read -ra PRS <<< "${{ env.PR_LIST }}"

          for PR_NUM in "${PRS[@]}"; do
            PR_NUM=$(echo "$PR_NUM" | tr -d ' ')

            if [ -z "$PR_NUM" ]; then
              continue
            fi

            echo "=========================================="
            echo "Processing PR #$PR_NUM"
            echo "=========================================="

            # Fetch PR information using GitHub API
            PR_INFO=$(curl -s -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/${{ env.UPSTREAM_REPO }}/pulls/$PR_NUM")

            PR_STATE=$(echo "$PR_INFO" | jq -r '.state')
            PR_TITLE=$(echo "$PR_INFO" | jq -r '.title')
            PR_HEAD_SHA=$(echo "$PR_INFO" | jq -r '.head.sha')
            PR_HEAD_REF=$(echo "$PR_INFO" | jq -r '.head.ref')
            PR_HEAD_REPO=$(echo "$PR_INFO" | jq -r '.head.repo.full_name')

            echo "PR Title: $PR_TITLE"
            echo "PR State: $PR_STATE"
            echo "PR Head SHA: $PR_HEAD_SHA"
            echo "PR Head Ref: $PR_HEAD_REF"
            echo "PR Head Repo: $PR_HEAD_REPO"

            if [ "$PR_STATE" = "null" ] || [ -z "$PR_STATE" ]; then
              echo "::warning::PR #$PR_NUM not found"
              FAILED_PRS="${FAILED_PRS}${PR_NUM}(not found),"
              continue
            fi

            # Fetch the PR's commits
            echo "Fetching PR #$PR_NUM from $PR_HEAD_REPO..."
            git fetch "https://github.com/$PR_HEAD_REPO.git" "$PR_HEAD_REF" || {
              echo "::warning::Failed to fetch PR #$PR_NUM"
              FAILED_PRS="${FAILED_PRS}${PR_NUM}(fetch failed),"
              continue
            }

            # Try to merge the PR
            echo "Merging PR #$PR_NUM..."
            if git merge --no-edit "$PR_HEAD_SHA" -m "Merge PR #$PR_NUM: $PR_TITLE"; then
              echo "::notice::Successfully merged PR #$PR_NUM: $PR_TITLE"
              MERGED_PRS="${MERGED_PRS}${PR_NUM},"
            else
              echo "::warning::Merge conflict for PR #$PR_NUM, attempting to abort..."
              git merge --abort || true
              FAILED_PRS="${FAILED_PRS}${PR_NUM}(conflict),"
            fi
          done

          # Remove trailing commas
          MERGED_PRS=${MERGED_PRS%,}
          FAILED_PRS=${FAILED_PRS%,}

          echo "merged_prs=$MERGED_PRS" >> $GITHUB_OUTPUT
          echo "failed_prs=$FAILED_PRS" >> $GITHUB_OUTPUT

          echo ""
          echo "=========================================="
          echo "Merge Summary"
          echo "=========================================="
          echo "Successfully merged: $MERGED_PRS"
          echo "Failed to merge: $FAILED_PRS"

          if [ -n "$FAILED_PRS" ]; then
            echo "::warning::Some PRs failed to merge: $FAILED_PRS"
          fi

      - name: Generate build metadata
        id: meta
        run: |
          BUILD_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          BUILD_VERSION=$(date -u +"%Y%m%d")

          echo "build_date=$BUILD_DATE" >> $GITHUB_OUTPUT
          echo "build_version=$BUILD_VERSION" >> $GITHUB_OUTPUT

          # Create version info file in the source
          cat > dokploy-source/ENHANCED_VERSION.json << EOF
          {
            "build_date": "$BUILD_DATE",
            "build_version": "$BUILD_VERSION",
            "upstream_sha": "${{ steps.clone.outputs.upstream_sha }}",
            "upstream_repo": "${{ env.UPSTREAM_REPO }}",
            "upstream_branch": "${{ inputs.dokploy_branch || env.UPSTREAM_BRANCH }}",
            "merged_prs": "${{ steps.merge-prs.outputs.merged_prs || '' }}",
            "failed_prs": "${{ steps.merge-prs.outputs.failed_prs || '' }}",
            "repository": "${{ github.repository }}",
            "run_id": "${{ github.run_id }}"
          }
          EOF

          cat dokploy-source/ENHANCED_VERSION.json

      - name: Prepare env files for build
        run: |
          cd dokploy-source
          # Copy the production env example files (required for build)
          cp apps/dokploy/.env.production.example .env.production
          cp apps/dokploy/.env.production.example apps/dokploy/.env.production
          echo "Environment files prepared successfully"
          ls -la .env.production apps/dokploy/.env.production

      - name: Patch Dockerfile to fix build issues
        run: |
          cd dokploy-source
          # Fix corepack and pnpm issues for reliable builds
          #
          # Problem 1: corepack signature validation fails with newer pnpm versions
          # See: https://github.com/nodejs/corepack/issues/612
          #
          # Problem 2: pnpm 10+ blocks native module builds (bcrypt, sharp) by default
          # See: https://github.com/pnpm/pnpm/issues/9042
          # See: https://pnpm.io/cli/approve-builds
          #
          # Solution:
          # 1. Set COREPACK_INTEGRITY_KEYS="" to bypass signature verification
          # 2. Configure pnpm to allow native module builds (bcrypt, sharp, etc.)
          # 3. Use architecture-specific cache for native modules

          echo "Original Dockerfile (first 20 lines):"
          head -20 Dockerfile

          # 1. Add COREPACK_INTEGRITY_KEYS="" to bypass signature verification
          sed -i '/ENV PATH="\$PNPM_HOME:\$PATH"/a ENV COREPACK_INTEGRITY_KEYS=""' Dockerfile

          # 2. Fix multi-arch builds: Use TARGETARCH in pnpm cache id
          sed -i 's/--mount=type=cache,id=pnpm/--mount=type=cache,id=pnpm-${TARGETARCH}/' Dockerfile

          # 3. Add TARGETARCH build arg if not present (needed for cache key)
          if ! grep -q "ARG TARGETARCH" Dockerfile; then
            sed -i '/FROM .* AS build/a ARG TARGETARCH' Dockerfile
          fi

          # 4. Configure pnpm 10+ to allow native module builds
          # pnpm 10 blocks lifecycle scripts by default for security
          # We need to allow bcrypt, sharp, and other native modules to build
          # Option A: Add onlyBuiltDependencies to pnpm-workspace.yaml
          # Option B: Use --config.onlyBuiltDependencies flag
          # We'll modify pnpm install commands to allow all builds in Docker context
          # This is safe since we're building from trusted upstream source
          echo ""
          echo "Configuring pnpm to allow native module builds..."

          # Replace 'pnpm install --frozen-lockfile' with version that allows builds
          sed -i 's/pnpm install --frozen-lockfile/pnpm install --frozen-lockfile --config.confirmModulesPurge=false/g' Dockerfile

          # 5. Fix pnpm v10+ deploy command
          # pnpm v10 requires inject-workspace-packages=true or --legacy flag
          # See: https://github.com/orgs/pnpm/discussions/9015
          # See: https://pnpm.io/cli/deploy
          echo ""
          echo "Patching pnpm deploy command for v10+ compatibility..."
          sed -i 's/pnpm deploy/pnpm deploy --legacy/g' Dockerfile
          sed -i 's/pnpm --filter=\(.*\) --prod deploy/pnpm --filter=\1 --prod deploy --legacy/g' Dockerfile

          # Create/update pnpm-workspace.yaml to allow native module builds and legacy deploy
          if [ -f "pnpm-workspace.yaml" ]; then
            echo "Updating pnpm-workspace.yaml..."
            # Check if onlyBuiltDependencies already exists
            if ! grep -q "onlyBuiltDependencies" pnpm-workspace.yaml; then
              {
                echo ''
                echo '# Added by dokploy-enhanced for pnpm v10+ compatibility'
                echo '# See: https://pnpm.io/settings'
                echo ''
                echo '# Allow pnpm deploy without inject-workspace-packages'
                echo '# See: https://pnpm.io/cli/deploy'
                echo 'forceLegacyDeploy: true'
                echo ''
                echo '# Allow native module builds'
                echo '# See: https://pnpm.io/settings#onlybuiltdependencies'
                echo 'onlyBuiltDependencies:'
                echo '  - bcrypt'
                echo '  - sharp'
                echo "  - '@node-rs/*'"
                echo '  - argon2'
                echo '  - esbuild'
                echo '  - turbo'
                echo '  - prisma'
                echo "  - '@prisma/client'"
              } >> pnpm-workspace.yaml
            fi
          else
            echo "Creating pnpm-workspace.yaml..."
            {
              echo 'packages:'
              echo "  - 'apps/*'"
              echo "  - 'packages/*'"
              echo ''
              echo '# Added by dokploy-enhanced for pnpm v10+ compatibility'
              echo '# See: https://pnpm.io/settings'
              echo ''
              echo '# Allow pnpm deploy without inject-workspace-packages'
              echo '# See: https://pnpm.io/cli/deploy'
              echo 'forceLegacyDeploy: true'
              echo ''
              echo '# Allow native module builds'
              echo '# See: https://pnpm.io/settings#onlybuiltdependencies'
              echo 'onlyBuiltDependencies:'
              echo '  - bcrypt'
              echo '  - sharp'
              echo "  - '@node-rs/*'"
              echo '  - argon2'
              echo '  - esbuild'
              echo '  - turbo'
              echo '  - prisma'
              echo "  - '@prisma/client'"
            } > pnpm-workspace.yaml
          fi

          echo ""
          echo "Patched Dockerfile (first 25 lines):"
          head -25 Dockerfile

          echo ""
          echo "pnpm-workspace.yaml contents:"
          cat pnpm-workspace.yaml || echo "No pnpm-workspace.yaml found"

          echo ""
          echo "Verifying pnpm version references:"
          grep -n "pnpm@" Dockerfile || echo "No pnpm@ references found in Dockerfile"

      - name: Upload prepared source
        uses: actions/upload-artifact@v4
        with:
          name: dokploy-source
          path: dokploy-source
          retention-days: 1
          # IMPORTANT: Include hidden files (files starting with .)
          # This is required for .env.production files to be included
          include-hidden-files: true

  # ==========================================================================
  # Build AMD64 Image
  # ==========================================================================
  build-amd64:
    needs: prepare-source
    if: ${{ inputs.skip_build != true }}
    runs-on: ubuntu-22.04
    steps:
      - name: Download prepared source
        uses: actions/download-artifact@v4
        with:
          name: dokploy-source
          path: dokploy-source

      - name: Verify env files exist
        run: |
          echo "Checking for required .env files..."
          ls -la dokploy-source/.env.production
          ls -la dokploy-source/apps/dokploy/.env.production
          echo "Environment files verified successfully"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push AMD64 image
        uses: docker/build-push-action@v5
        with:
          context: ./dokploy-source
          file: ./dokploy-source/Dockerfile
          platforms: linux/amd64
          push: true
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.prepare-source.outputs.build_version }}-amd64
          cache-from: type=gha,scope=amd64
          cache-to: type=gha,mode=max,scope=amd64

  # ==========================================================================
  # Build ARM64 Image
  # ==========================================================================
  build-arm64:
    needs: prepare-source
    if: ${{ inputs.skip_build != true }}
    runs-on: ubuntu-24.04-arm
    steps:
      - name: Download prepared source
        uses: actions/download-artifact@v4
        with:
          name: dokploy-source
          path: dokploy-source

      - name: Verify env files exist
        run: |
          echo "Checking for required .env files..."
          ls -la dokploy-source/.env.production
          ls -la dokploy-source/apps/dokploy/.env.production
          echo "Environment files verified successfully"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push ARM64 image
        uses: docker/build-push-action@v5
        with:
          context: ./dokploy-source
          file: ./dokploy-source/Dockerfile
          platforms: linux/arm64
          push: true
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.prepare-source.outputs.build_version }}-arm64
          cache-from: type=gha,scope=arm64
          cache-to: type=gha,mode=max,scope=arm64

  # ==========================================================================
  # Create Multi-Arch Manifests
  # ==========================================================================
  create-manifests:
    needs: [prepare-source, build-amd64, build-arm64]
    if: ${{ inputs.skip_build != true }}
    runs-on: ubuntu-latest
    steps:
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Create and push multi-arch manifests
        run: |
          BUILD_VERSION="${{ needs.prepare-source.outputs.build_version }}"
          IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}"

          echo "Creating multi-arch manifests for version: $BUILD_VERSION"

          # Create manifest for the dated version
          docker buildx imagetools create -t ${IMAGE}:${BUILD_VERSION} \
            ${IMAGE}:${BUILD_VERSION}-amd64 \
            ${IMAGE}:${BUILD_VERSION}-arm64

          # Create manifest for 'latest'
          docker buildx imagetools create -t ${IMAGE}:latest \
            ${IMAGE}:${BUILD_VERSION}-amd64 \
            ${IMAGE}:${BUILD_VERSION}-arm64

          # Create manifest for 'canary' if building from canary branch
          BRANCH="${{ inputs.dokploy_branch || env.UPSTREAM_BRANCH }}"
          if [ "$BRANCH" = "canary" ]; then
            docker buildx imagetools create -t ${IMAGE}:canary \
              ${IMAGE}:${BUILD_VERSION}-amd64 \
              ${IMAGE}:${BUILD_VERSION}-arm64
          fi

          echo "Manifests created successfully!"

      - name: Verify manifests
        run: |
          IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}"
          echo "Inspecting latest manifest:"
          docker buildx imagetools inspect ${IMAGE}:latest

  # ==========================================================================
  # Generate Build Summary
  # ==========================================================================
  build-summary:
    needs: [prepare-source, create-manifests]
    if: always() && needs.prepare-source.result == 'success'
    runs-on: ubuntu-latest
    steps:
      - name: Generate build summary
        run: |
          echo "## Dokploy Enhanced Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Source Configuration" >> $GITHUB_STEP_SUMMARY
          echo "| Setting | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Upstream Repository | \`${{ env.UPSTREAM_REPO }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Upstream Branch | \`${{ inputs.dokploy_branch || env.UPSTREAM_BRANCH }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Upstream SHA | \`${{ needs.prepare-source.outputs.upstream_sha }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### PR Merge Results" >> $GITHUB_STEP_SUMMARY
          echo "| Status | PRs |" >> $GITHUB_STEP_SUMMARY
          echo "|--------|-----|" >> $GITHUB_STEP_SUMMARY
          echo "| Successfully Merged | ${{ needs.prepare-source.outputs.merged_prs || 'None' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Failed to Merge | ${{ needs.prepare-source.outputs.failed_prs || 'None' }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ inputs.skip_build }}" != "true" ]; then
            echo "### Docker Images" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The following tags have been published to \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}\`:" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Tag | Description |" >> $GITHUB_STEP_SUMMARY
            echo "|-----|-------------|" >> $GITHUB_STEP_SUMMARY
            echo "| \`latest\` | Most recent build |" >> $GITHUB_STEP_SUMMARY
            echo "| \`${{ needs.prepare-source.outputs.build_version }}\` | Date-versioned build |" >> $GITHUB_STEP_SUMMARY
            echo "| \`canary\` | Canary channel (if applicable) |" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Pull command:**" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`bash" >> $GITHUB_STEP_SUMMARY
            echo "docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          else
            echo "### Build Status" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Docker build was skipped (skip_build=true)" >> $GITHUB_STEP_SUMMARY
          fi

  # ==========================================================================
  # Notify on Failure
  # ==========================================================================
  notify-on-failure:
    needs: [prepare-source, build-amd64, build-arm64, create-manifests]
    runs-on: ubuntu-latest
    if: failure()
    steps:
      - name: Create failure issue
        uses: actions/github-script@v7
        with:
          script: |
            const title = `Build Failed: ${new Date().toISOString().split('T')[0]}`;
            const body = `
            ## Automated Build Failed

            **Workflow Run:** [#${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
            **Date:** ${new Date().toISOString()}

            ### Job Status
            - prepare-source: ${{ needs.prepare-source.result || 'N/A' }}
            - build-amd64: ${{ needs.build-amd64.result || 'N/A' }}
            - build-arm64: ${{ needs.build-arm64.result || 'N/A' }}
            - create-manifests: ${{ needs.create-manifests.result || 'N/A' }}

            Please check the workflow logs for details.
            `;

            // Check if issue already exists today
            const today = new Date().toISOString().split('T')[0];
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'build-failure'
            });

            const existingIssue = issues.data.find(issue =>
              issue.title.includes(today)
            );

            if (!existingIssue) {
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: title,
                body: body,
                labels: ['build-failure', 'automated']
              });
            } else {
              // Update existing issue with new run info
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: existingIssue.number,
                body: `Another build failed: [Run #${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})`
              });
            }
