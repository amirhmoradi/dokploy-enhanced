name: Auto-Merge PRs and Build Enhanced Dokploy

on:
  schedule:
    # Run daily at 00:00 UTC
    - cron: '0 0 * * *'
  workflow_dispatch:
    inputs:
      pr_numbers:
        description: 'Comma-separated PR numbers to merge (overrides env variable)'
        required: false
        type: string
      dokploy_branch:
        description: 'Dokploy branch to use as base (default: canary)'
        required: false
        default: 'canary'
        type: string
      skip_build:
        description: 'Skip Docker build (useful for testing merge only)'
        required: false
        default: false
        type: boolean

env:
  # Configure PR numbers to merge (comma-separated)
  # Example: "1234,5678,9012"
  PR_NUMBERS_TO_MERGE: ${{ vars.PR_NUMBERS_TO_MERGE || '' }}

  # Docker registry configuration
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository_owner }}/dokploy-enhanced

  # Upstream Dokploy repository
  UPSTREAM_REPO: Dokploy/dokploy
  UPSTREAM_BRANCH: canary

# Permissions required for pushing to ghcr.io
permissions:
  contents: read
  packages: write

jobs:
  # ==========================================================================
  # Clone and Merge PRs
  # ==========================================================================
  prepare-source:
    runs-on: ubuntu-latest
    outputs:
      merged_prs: ${{ steps.merge-prs.outputs.merged_prs }}
      failed_prs: ${{ steps.merge-prs.outputs.failed_prs }}
      build_version: ${{ steps.meta.outputs.build_version }}
      enhanced_version_tag: ${{ steps.meta.outputs.enhanced_version_tag }}
      upstream_release: ${{ steps.meta.outputs.upstream_release }}
      upstream_sha: ${{ steps.clone.outputs.upstream_sha }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Git
        run: |
          git config --global user.name "GitHub Actions Bot"
          git config --global user.email "actions@github.com"

      - name: Clone upstream Dokploy repository
        id: clone
        run: |
          BRANCH="${{ inputs.dokploy_branch || env.UPSTREAM_BRANCH }}"
          echo "Cloning upstream Dokploy from branch: $BRANCH"
          git clone --depth=1 --branch "$BRANCH" "https://github.com/${{ env.UPSTREAM_REPO }}.git" dokploy-source
          cd dokploy-source
          git fetch --unshallow || true
          UPSTREAM_SHA=$(git rev-parse HEAD)
          echo "upstream_sha=$UPSTREAM_SHA" >> $GITHUB_OUTPUT
          echo "Upstream SHA: $UPSTREAM_SHA"

      - name: Determine PRs to merge
        id: determine-prs
        run: |
          # Use workflow input if provided, otherwise use env variable
          if [ -n "${{ inputs.pr_numbers }}" ]; then
            PR_LIST="${{ inputs.pr_numbers }}"
          else
            PR_LIST="${{ env.PR_NUMBERS_TO_MERGE }}"
          fi

          echo "PR_LIST=$PR_LIST" >> $GITHUB_ENV
          echo "PRs to merge: $PR_LIST"

          if [ -z "$PR_LIST" ]; then
            echo "No PRs configured to merge"
            echo "has_prs=false" >> $GITHUB_OUTPUT
          else
            echo "has_prs=true" >> $GITHUB_OUTPUT
          fi

      - name: Fetch and merge PRs
        id: merge-prs
        if: steps.determine-prs.outputs.has_prs == 'true'
        run: |
          cd dokploy-source

          MERGED_PRS=""
          FAILED_PRS=""

          # Parse comma-separated PR numbers
          IFS=',' read -ra PRS <<< "${{ env.PR_LIST }}"

          for PR_NUM in "${PRS[@]}"; do
            PR_NUM=$(echo "$PR_NUM" | tr -d ' ')

            if [ -z "$PR_NUM" ]; then
              continue
            fi

            echo "=========================================="
            echo "Processing PR #$PR_NUM"
            echo "=========================================="

            # Fetch PR information using GitHub API
            PR_INFO=$(curl -s -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/${{ env.UPSTREAM_REPO }}/pulls/$PR_NUM")

            PR_STATE=$(echo "$PR_INFO" | jq -r '.state')
            PR_TITLE=$(echo "$PR_INFO" | jq -r '.title')
            PR_HEAD_SHA=$(echo "$PR_INFO" | jq -r '.head.sha')
            PR_HEAD_REF=$(echo "$PR_INFO" | jq -r '.head.ref')
            PR_HEAD_REPO=$(echo "$PR_INFO" | jq -r '.head.repo.full_name')

            echo "PR Title: $PR_TITLE"
            echo "PR State: $PR_STATE"
            echo "PR Head SHA: $PR_HEAD_SHA"
            echo "PR Head Ref: $PR_HEAD_REF"
            echo "PR Head Repo: $PR_HEAD_REPO"

            if [ "$PR_STATE" = "null" ] || [ -z "$PR_STATE" ]; then
              echo "::warning::PR #$PR_NUM not found"
              FAILED_PRS="${FAILED_PRS}${PR_NUM}(not found),"
              continue
            fi

            # Fetch the PR's commits
            echo "Fetching PR #$PR_NUM from $PR_HEAD_REPO..."
            git fetch "https://github.com/$PR_HEAD_REPO.git" "$PR_HEAD_REF" || {
              echo "::warning::Failed to fetch PR #$PR_NUM"
              FAILED_PRS="${FAILED_PRS}${PR_NUM}(fetch failed),"
              continue
            }

            # Try to merge the PR
            echo "Merging PR #$PR_NUM..."
            if git merge --no-edit "$PR_HEAD_SHA" -m "Merge PR #$PR_NUM: $PR_TITLE"; then
              echo "::notice::Successfully merged PR #$PR_NUM: $PR_TITLE"
              MERGED_PRS="${MERGED_PRS}${PR_NUM},"
            else
              echo "::warning::Merge conflict for PR #$PR_NUM, attempting to abort..."
              git merge --abort || true
              FAILED_PRS="${FAILED_PRS}${PR_NUM}(conflict),"
            fi
          done

          # Remove trailing commas
          MERGED_PRS=${MERGED_PRS%,}
          FAILED_PRS=${FAILED_PRS%,}

          echo "merged_prs=$MERGED_PRS" >> $GITHUB_OUTPUT
          echo "failed_prs=$FAILED_PRS" >> $GITHUB_OUTPUT

          echo ""
          echo "=========================================="
          echo "Merge Summary"
          echo "=========================================="
          echo "Successfully merged: $MERGED_PRS"
          echo "Failed to merge: $FAILED_PRS"

          if [ -n "$FAILED_PRS" ]; then
            echo "::warning::Some PRs failed to merge: $FAILED_PRS"
          fi

      - name: Generate build metadata
        id: meta
        run: |
          BUILD_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          BUILD_VERSION=$(date -u +"%Y%m%d")

          echo "Fetching latest upstream release tag..."
          LATEST_RELEASE=$(curl -s -H "Accept: application/vnd.github+json" "https://api.github.com/repos/${{ env.UPSTREAM_REPO }}/releases/latest" | jq -r '.tag_name')

          if [ -z "$LATEST_RELEASE" ] || [ "$LATEST_RELEASE" = "null" ]; then
            echo "::warning::Unable to determine latest upstream release; defaulting to branch name"
            LATEST_RELEASE="${{ inputs.dokploy_branch || env.UPSTREAM_BRANCH }}"
          fi

          echo "Latest upstream release: $LATEST_RELEASE"

          MERGED_PRS="${{ steps.merge-prs.outputs.merged_prs || '' }}"
          CLEANED_MERGED=$(echo "$MERGED_PRS" | tr -d ' ')

          if [ -n "$CLEANED_MERGED" ]; then
            PR_SUFFIX=$(echo "$CLEANED_MERGED" | tr ',' '-')
            ENHANCED_TAG="${LATEST_RELEASE}.pr-${PR_SUFFIX}"
          else
            ENHANCED_TAG="$LATEST_RELEASE"
          fi

          echo "Enhanced version tag: $ENHANCED_TAG"

          echo "build_date=$BUILD_DATE" >> $GITHUB_OUTPUT
          echo "build_version=$BUILD_VERSION" >> $GITHUB_OUTPUT
          echo "upstream_release=$LATEST_RELEASE" >> $GITHUB_OUTPUT
          echo "enhanced_version_tag=$ENHANCED_TAG" >> $GITHUB_OUTPUT

          # Create version info file in the source
          cat > dokploy-source/ENHANCED_VERSION.json << EOF
          {
            "build_date": "$BUILD_DATE",
            "build_version": "$BUILD_VERSION",
            "upstream_release": "$LATEST_RELEASE",
            "upstream_sha": "${{ steps.clone.outputs.upstream_sha }}",
            "upstream_repo": "${{ env.UPSTREAM_REPO }}",
            "upstream_branch": "${{ inputs.dokploy_branch || env.UPSTREAM_BRANCH }}",
            "enhanced_version_tag": "$ENHANCED_TAG",
            "merged_prs": "${{ steps.merge-prs.outputs.merged_prs || '' }}",
            "failed_prs": "${{ steps.merge-prs.outputs.failed_prs || '' }}",
            "repository": "${{ github.repository }}",
            "run_id": "${{ github.run_id }}"
          }
          EOF

          cat dokploy-source/ENHANCED_VERSION.json

      - name: Prepare env files for build
        run: |
          cd dokploy-source
          # Copy the production env example files (required for build)
          cp apps/dokploy/.env.production.example .env.production
          cp apps/dokploy/.env.production.example apps/dokploy/.env.production
          echo "Environment files prepared successfully"
          ls -la .env.production apps/dokploy/.env.production

      - name: Patch Dockerfile to fix build issues
        run: |
          cd dokploy-source
          # Fix corepack and pnpm issues for reliable builds
          #
          # Problem: corepack signature validation can fail with certain pnpm versions
          # See: https://github.com/nodejs/corepack/issues/612
          #
          # Solution:
          # 1. Pin pnpm to version 9.x (same as upstream Dokploy) to avoid pnpm 10 breaking changes
          # 2. Set COREPACK_INTEGRITY_KEYS="" to bypass signature verification
          # 3. Use architecture-specific cache for native modules

          echo "Original Dockerfile (first 20 lines):"
          head -20 Dockerfile

          # 1. Pin pnpm to version 9 to match upstream and avoid pnpm 10 breaking changes
          # pnpm 10 has breaking changes that require maintaining a list of native modules
          echo ""
          echo "Pinning pnpm to version 9.x..."

          # Find and replace pnpm version in packageManager field or corepack enable
          # First, update package.json if it specifies pnpm version
          if [ -f "package.json" ]; then
            # Check current pnpm version in package.json
            echo "Current package.json packageManager:"
            grep -o '"packageManager"[^,}]*' package.json || echo "No packageManager field found"

            # Replace any pnpm@10.x with pnpm@9.15.0
            sed -i 's/"pnpm@10\.[^"]*"/"pnpm@9.15.0"/g' package.json
            sed -i 's/"pnpm@latest"/"pnpm@9.15.0"/g' package.json

            # If no packageManager field exists, the Dockerfile handles it
            echo "Updated package.json packageManager:"
            grep -o '"packageManager"[^,}]*' package.json || echo "No packageManager field found"
          fi

          # Also patch the Dockerfile to ensure pnpm 9 is used
          # Replace any corepack enable pnpm@10 with pnpm@9
          sed -i 's/corepack enable pnpm@10/corepack enable pnpm@9/g' Dockerfile
          sed -i 's/corepack prepare pnpm@10/corepack prepare pnpm@9/g' Dockerfile

          # If Dockerfile uses corepack enable without version, add version pinning
          # Add pnpm version pin after corepack enable if not already versioned
          sed -i 's/RUN corepack enable$/RUN corepack enable \&\& corepack prepare pnpm@9.15.0 --activate/g' Dockerfile

          # 2. Add COREPACK_INTEGRITY_KEYS="" to bypass signature verification
          sed -i '/ENV PATH="\$PNPM_HOME:\$PATH"/a ENV COREPACK_INTEGRITY_KEYS=""' Dockerfile

          # 3. Fix multi-arch builds: Use TARGETARCH in pnpm cache id
          sed -i 's/--mount=type=cache,id=pnpm/--mount=type=cache,id=pnpm-${TARGETARCH}/' Dockerfile

          # 4. Add TARGETARCH build arg if not present (needed for cache key)
          if ! grep -q "ARG TARGETARCH" Dockerfile; then
            sed -i '/FROM .* AS build/a ARG TARGETARCH' Dockerfile
          fi

          echo ""
          echo "Patched Dockerfile (first 30 lines):"
          head -30 Dockerfile

          echo ""
          echo "Verifying pnpm version references:"
          grep -n "pnpm" Dockerfile | head -20 || echo "No pnpm references found"

          echo ""
          echo "package.json packageManager field:"
          grep "packageManager" package.json || echo "No packageManager in package.json"

      - name: Upload prepared source
        uses: actions/upload-artifact@v4
        with:
          name: dokploy-source
          path: dokploy-source
          retention-days: 1
          # IMPORTANT: Include hidden files (files starting with .)
          # This is required for .env.production files to be included
          include-hidden-files: true

  # ==========================================================================
  # Build AMD64 Image
  # ==========================================================================
  build-amd64:
    needs: prepare-source
    if: ${{ inputs.skip_build != true }}
    runs-on: ubuntu-22.04
    steps:
      - name: Download prepared source
        uses: actions/download-artifact@v4
        with:
          name: dokploy-source
          path: dokploy-source

      - name: Verify env files exist
        run: |
          echo "Checking for required .env files..."
          ls -la dokploy-source/.env.production
          ls -la dokploy-source/apps/dokploy/.env.production
          echo "Environment files verified successfully"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push AMD64 image
        uses: docker/build-push-action@v5
        with:
          context: ./dokploy-source
          file: ./dokploy-source/Dockerfile
          platforms: linux/amd64
          push: true
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.prepare-source.outputs.build_version }}-amd64,${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.prepare-source.outputs.enhanced_version_tag }}-amd64
          cache-from: type=gha,scope=amd64
          cache-to: type=gha,mode=max,scope=amd64

  # ==========================================================================
  # Build ARM64 Image
  # ==========================================================================
  build-arm64:
    needs: prepare-source
    if: ${{ inputs.skip_build != true }}
    runs-on: ubuntu-24.04-arm
    steps:
      - name: Download prepared source
        uses: actions/download-artifact@v4
        with:
          name: dokploy-source
          path: dokploy-source

      - name: Verify env files exist
        run: |
          echo "Checking for required .env files..."
          ls -la dokploy-source/.env.production
          ls -la dokploy-source/apps/dokploy/.env.production
          echo "Environment files verified successfully"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push ARM64 image
        uses: docker/build-push-action@v5
        with:
          context: ./dokploy-source
          file: ./dokploy-source/Dockerfile
          platforms: linux/arm64
          push: true
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.prepare-source.outputs.build_version }}-arm64,${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.prepare-source.outputs.enhanced_version_tag }}-arm64
          cache-from: type=gha,scope=arm64
          cache-to: type=gha,mode=max,scope=arm64

  # ==========================================================================
  # Create Multi-Arch Manifests
  # ==========================================================================
  create-manifests:
    needs: [prepare-source, build-amd64, build-arm64]
    if: ${{ inputs.skip_build != true }}
    runs-on: ubuntu-latest
    steps:
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Create and push multi-arch manifests
        run: |
          BUILD_VERSION="${{ needs.prepare-source.outputs.build_version }}"
          ENHANCED_VERSION="${{ needs.prepare-source.outputs.enhanced_version_tag }}"
          IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}"

          echo "Creating multi-arch manifests for version: $BUILD_VERSION"

          # Create manifest for the dated version
          docker buildx imagetools create -t ${IMAGE}:${BUILD_VERSION} \
            ${IMAGE}:${BUILD_VERSION}-amd64 \
            ${IMAGE}:${BUILD_VERSION}-arm64

          # Create manifest for the enhanced upstream/PR version tag
          docker buildx imagetools create -t ${IMAGE}:${ENHANCED_VERSION} \
            ${IMAGE}:${BUILD_VERSION}-amd64 \
            ${IMAGE}:${BUILD_VERSION}-arm64

          # Create manifest for 'latest'
          docker buildx imagetools create -t ${IMAGE}:latest \
            ${IMAGE}:${BUILD_VERSION}-amd64 \
            ${IMAGE}:${BUILD_VERSION}-arm64

          # Create manifest for 'canary' if building from canary branch
          BRANCH="${{ inputs.dokploy_branch || env.UPSTREAM_BRANCH }}"
          if [ "$BRANCH" = "canary" ]; then
            docker buildx imagetools create -t ${IMAGE}:canary \
              ${IMAGE}:${BUILD_VERSION}-amd64 \
              ${IMAGE}:${BUILD_VERSION}-arm64
          fi

          echo "Manifests created successfully!"

      - name: Verify manifests
        run: |
          IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}"
          echo "Inspecting latest manifest:"
          docker buildx imagetools inspect ${IMAGE}:latest

  # ==========================================================================
  # Generate Build Summary
  # ==========================================================================
  build-summary:
    needs: [prepare-source, create-manifests]
    if: always() && needs.prepare-source.result == 'success'
    runs-on: ubuntu-latest
    steps:
      - name: Generate build summary
        run: |
          echo "## Dokploy Enhanced Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Source Configuration" >> $GITHUB_STEP_SUMMARY
          echo "| Setting | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Upstream Repository | \`${{ env.UPSTREAM_REPO }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Upstream Branch | \`${{ inputs.dokploy_branch || env.UPSTREAM_BRANCH }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Upstream SHA | \`${{ needs.prepare-source.outputs.upstream_sha }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### PR Merge Results" >> $GITHUB_STEP_SUMMARY
          echo "| Status | PRs |" >> $GITHUB_STEP_SUMMARY
          echo "|--------|-----|" >> $GITHUB_STEP_SUMMARY
          echo "| Successfully Merged | ${{ needs.prepare-source.outputs.merged_prs || 'None' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Failed to Merge | ${{ needs.prepare-source.outputs.failed_prs || 'None' }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "### Version Tags" >> $GITHUB_STEP_SUMMARY
          echo "| Description | Tag |" >> $GITHUB_STEP_SUMMARY
          echo "|-------------|-----|" >> $GITHUB_STEP_SUMMARY
          echo "| Latest upstream release | \`${{ needs.prepare-source.outputs.upstream_release }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Enhanced build tag | \`${{ needs.prepare-source.outputs.enhanced_version_tag }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Date-based build tag | \`${{ needs.prepare-source.outputs.build_version }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ inputs.skip_build }}" != "true" ]; then
            echo "### Docker Images" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The following tags have been published to \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}\`:" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Tag | Description |" >> $GITHUB_STEP_SUMMARY
            echo "|-----|-------------|" >> $GITHUB_STEP_SUMMARY
            echo "| \`latest\` | Most recent build |" >> $GITHUB_STEP_SUMMARY
            echo "| \`${{ needs.prepare-source.outputs.enhanced_version_tag }}\` | Upstream release + merged PRs |" >> $GITHUB_STEP_SUMMARY
            echo "| \`${{ needs.prepare-source.outputs.build_version }}\` | Date-versioned build |" >> $GITHUB_STEP_SUMMARY
            echo "| \`canary\` | Canary channel (if applicable) |" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Pull command:**" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`bash" >> $GITHUB_STEP_SUMMARY
            echo "docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          else
            echo "### Build Status" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Docker build was skipped (skip_build=true)" >> $GITHUB_STEP_SUMMARY
          fi

  # ==========================================================================
  # Notify on Failure
  # ==========================================================================
  notify-on-failure:
    needs: [prepare-source, build-amd64, build-arm64, create-manifests]
    runs-on: ubuntu-latest
    if: failure()
    steps:
      - name: Create failure issue
        uses: actions/github-script@v7
        with:
          script: |
            const title = `Build Failed: ${new Date().toISOString().split('T')[0]}`;
            const body = `
            ## Automated Build Failed

            **Workflow Run:** [#${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
            **Date:** ${new Date().toISOString()}

            ### Job Status
            - prepare-source: ${{ needs.prepare-source.result || 'N/A' }}
            - build-amd64: ${{ needs.build-amd64.result || 'N/A' }}
            - build-arm64: ${{ needs.build-arm64.result || 'N/A' }}
            - create-manifests: ${{ needs.create-manifests.result || 'N/A' }}

            Please check the workflow logs for details.
            `;

            // Check if issue already exists today
            const today = new Date().toISOString().split('T')[0];
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'build-failure'
            });

            const existingIssue = issues.data.find(issue =>
              issue.title.includes(today)
            );

            if (!existingIssue) {
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: title,
                body: body,
                labels: ['build-failure', 'automated']
              });
            } else {
              // Update existing issue with new run info
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: existingIssue.number,
                body: `Another build failed: [Run #${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})`
              });
            }
